
								The^day^of^DooM

								  AVR-OS 0.73

							Create date:	15.01.2008
							Last Update:	17.01.2008
							Last Update:	02.02.2009

02.02.2009 (21:55 AM):
		Системния таймер (task manager) вече е TIMER2 (OC2). Започнах рабоа по часовник за реално
	врем (rtc). "Прикачен" е към TIMER1 (OCIE1A) и е с период 1ms при 16MHz. Кода му се намира във
	файла "rtc.inc". За момента само прекъсването му е добавено (работещо) към операционата система.
	
01.02.2009 (21:55 AM):
		Оптимизирах OSAddIRQToTaskF и OSRemoveIRQFromTaskF: при добавяне/премахване на прекъсване в
	таблицата на прекъсванията вече първо се проверява номера на желаното прекъсване на кой байт
	отговаря и тогава се обработва (добавя/премахва). Преди се правеше последователна проверка на
	всичките байтове до намиране на желания. Също има още една възможност за оптимизация: в момента
	нулирането бита на прекъсването в съответния байт е "ръчно" (примерно cbi r18, 3), а би могло да
	се ползват логически оператори. Всъщност причината за тази организация е това, че е възможно при
	някой прексвания да се налага допълнителна иницялизация на хардуера. Същото важи и за функцията
	за добавяне на прекъсвания. С две думи двете биха могли да се оптимизарат, при това много, всичко
	ще се реши на по-късен етап. А и да не забравя - покрай тях би могла да го отнесе и OSAddIRQToTaskF.


31.01.2009 (21:02 AM):
		Днес, след продължителен застой, реших да видя как се държи операционата система. Направих
	тест, който отдавна отлагах: на системата на прекъсванията. Имаше малък бъг който беше отстранен.
	Просто не съм обновявал системната променлива CURRENT_TASK (номера на текущия процес). Във версия
	0.72 тя служеше за намиране на адреса на текущия процес докато в текущата версия беше забравена.
	А подсистемата на прекъсванията я ползва интезивно... Лошото е, че прочиташе невалидна стойност и
	пишеше на места в паметта където не и бе работа. Жалко, че няма защита на памета.

17.01.2008 (01:48 PM):
		Предварителните тестове на оптимизирания malloc показват добри резултати. Но имаики в
	предвит, че проблемите се появяват когато най-малко очаква човек...
		Беше премахнат неприятен бъг в частта свързана със съобщенията. OSReadMessageF връщаше
	порменени параметри (съобщението го връщаша за подател, а подателя за съощение). Имаше и
	подобни при входните параметри на OSSendMessageF - явно при последната редакция съм разменил
	регистрите по невнимание. Вече са преработени да работят с новата операциона - правят
	проверка дали върнатия Z указател е различен от нула (сочи ли към валиден процес).

16.01.2008 (23:49 AM):
		Доабавих и контролната променлива на malloc/free. Раположена е между стека определен
	от MM (стека на OS) и таблицата на заделени указатели (променливата съхраняваща горния
	и край (на memory heap). Oстава системата да мине множество тестове, премахване
	на проемнливи, код и хакове от старите версии. А и най-важното: оптимизация на malloc.
	Важмо е да отбележа, че вече процесите получават уникално ID при създаването си. Както е
	тръгнало ще се наложи от версия 0.73 да стане направо 0.8. Събраха се твърде много различия
	спрямо старите версии. Реално между 0.1 и сегашната има цяла пропаст.

16.01.2008 (23:09 AM):
		Кофти тръпка е писането на свързан списък на ASM. Но уж му хванах цаката. Вземам готов
	код на C и го "превеждам". Иначе кашата с указателите става пълна. Сега гледам да го
	напиша колкото се може по-кадърно, че ако ми се наложи след време да го преправям...
	Много здрава боза се получи: кода на операционата разполага старшия байт на променливите
	в младшите адреси. Когато съм го писал ми е било по-лесно в debug режим. Но новия код,
	най-вече часта на MM, използва точно обратния подход. Май от AVR-GCC съм го прихванал?
	Важното е, че вече базовия набор от функции работи. Примерния тест Example.asm от
	версия 0.72 тръгна а на него не един път съм хващал бъгове в ядрото. Всъщност в момента
	ще се издъни здравата при едновремено заделяне/освобождаване на памет от два процеса.
	Но това е познат проблем, ще се реши с добавяне на контролна променлива "казваща" на
	malloc/free дали в момента работи някоя от двете в друг процес. Интересно нещо е
	многозадачноста, а още по-интересно е тестването на код работещ в такъв режим.

16.01.2008 (03:04 PM):
		И най-сетне започна работа по версия 0.73. Както споменах в проекта LPC, и отделния
	тестов mem, вече операционата може да се похвали с реално управление на паметта.
	Масива на процесите е заменен с едносвързан списък. Даже и работи ;) Все пак да не
	избързвам. Кода е на ниво тестове, а опита ми подсказва, че тепърва ще стане
	страшно. Притеснява ме реализацията на списъка, но по-вече управлението на паметта.
	Мисля, че малко избързах с добавянето му към операционата - трябваше да мине по-обстоен
	тест. Ще се наложи да подобря скороста на malloc. Важно е да отбележда, че функцията
	за премахване на процес в момента е неработоспособна. А CreateTask 100% ще ми създаде
	главоболия. Е, положението не е толкова страшно;) Щом OSTaskManagerF се спрява с
	превключването на процесите значи има надежда 8) Нали най-накрая започна работата по
	новата версия, другото не е от значение.
